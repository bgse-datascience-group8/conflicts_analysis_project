extends layout

block head
  title=title
  style.
    .background {
      fill: none;
      pointer-events: all;
    }

    #states {
      fill: #aaa;
    }

    #states .active {
      fill: orange;
    }

    #state-borders {
      fill: none;
      stroke: #fff;
      stroke-width: 1.5px;
      stroke-linejoin: round;
      stroke-linecap: round;
      pointer-events: none;
    }

    .events-circle {
      color: #ffffff;
      fill: .000001;
      opacity: .000001;
    }

block content
  div.container
    div.jumbotron
      h1 Map
    script(src='javascripts/d3.v3.min.js')
    script(src='javascripts/topojson.v1.min.js')
    script.
      var renderMap = function() {
        //Speed & animation-control variables
        var maprate = 3000,
          pause = 0,
          timepause=0,
          start = 0,
          interval,
          loop,
          dates,
          dateiter = 0;

        var minDate = new Date('02 April 2013'),
            maxDate = new Date('05 November 2015'),
            timescale = d3.time.scale()// .toISOString().substring(0,10)

        timescale.domain([minDate, maxDate])

        var dates = d3.time.day.range(minDate, maxDate)

        var width = 960,
            height = 500,
            centered;

        var projection = d3.geo.albersUsa()
            .scale(1070)
            .translate([width / 2, height / 2]);

        var path = d3.geo.path()
            .projection(projection);

        var svg = d3.select(".jumbotron").append("svg")
            .attr("width", width)
            .attr("height", height);

        svg.append("rect")
            .attr("class", "background")
            .attr("width", width)
            .attr("height", height)
            .on("click", clicked);

        var g = svg.append("g");

        var circles = svg.append("svg:g")
          .attr("id", "circles");
        console.log('hi')

        d3.json("javascripts/us.json", function(error, us) {
          if (error) throw error;

          g.append("g")
              .attr("id", "states")
            .selectAll("path")
              .data(topojson.feature(us, us.objects.states).features)
            .enter().append("path")
              .attr("d", path)
              .on("click", clicked);

          g.append("path")
              .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
              .attr("id", "state-borders")
              .attr("d", path);

          renderCities();
        });

        function clicked(d) {
          var x, y, k;

          if (d && centered !== d) {
            var centroid = path.centroid(d);
            x = centroid[0];
            y = centroid[1];
            k = 4;
            centered = d;
          } else {
            x = width / 2;
            y = height / 2;
            k = 1;
            centered = null;
          }

          g.selectAll("path")
              .classed("active", centered && function(d) { return d === centered; });

          g.transition()
              .duration(750)
              .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")")
              .style("stroke-width", 1.5 / k + "px");

          circles.transition()
              .duration(750)
              .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + k + ")translate(" + -x + "," + -y + ")")
              .style("stroke-width", 1.5 / k + "px");
        }

        function renderCities() {
          updateMap = function(date) {
            date = date.toISOString().substring(0,10)
            d3.json("javascripts/events/" + date + ".json", function(events) {
              positions = [];

              events.forEach(function(event) {
                var location = [+event.long, +event.lat];
                positions.push(projection(location));
              });

              var datapoints = d3.select("#circles").selectAll("circle")
                .data(events)
                .enter()
                .append("circle");
                //.attr("class", 'events-circle');
              datapoints.attr("class", 'events-circle')
              datapoints
                .transition()
                    .duration(475)
                    .style("fill", "#ff0000")
                    .style("opacity", 1)
                    .attr("r", function(d,i){return d.nummentions/3})
                    .attr("cx", function(d,i){return positions[i][0]})
                    .attr("cy", function(d,i){return positions[i][1]})
                  .transition()
                    .duration(300)
                    .attr("r", function(d,i){return d.nummentions/3})
                    .attr("cx", function(d,i){return positions[i][0]})
                    .attr("cy", function(d,i){return positions[i][1]})
                    .style("fill", "#ff0000")
                    .style("opacity", 0.7)
                  .transition()
                    .duration(250)
                    .attr("r", function(d,i){return d.nummentions/3})
                    .attr("cx", function(d,i){return positions[i][0]})
                    .attr("cy", function(d,i){return positions[i][1]})
                    .style("fill", "#ff0000")
                    .style("opacity", 0.5)
                  .transition()
                    .duration(250)
                    .attr("r", function(d,i){return d.nummentions/3})
                    .attr("cx", function(d,i){return positions[i][0]})
                    .attr("cy", function(d,i){return positions[i][1]})
                    .style("fill", "#ff0000")
                    .style("opacity", 0.2)
                  .remove();
            })
          }

          loop = function(){
            clearInterval(interval);
            if ((timepause == 0 && pause == 0) || start == 0) {
              updateMap(dates[dateiter]);
              if (dateiter < dates.length - 1) {
                ++dateiter;
              }
              else {
                dateiter = 0;
                timepause = 1;
                setTimeout(function(){timepause = 0;}, maprate);
              }
            }
            start = 1;
            interval = setInterval(loop, maprate);
          }

          interval = setInterval(loop, maprate);
        };
      }
      renderMap()
